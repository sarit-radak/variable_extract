import os
import sys
from numpy import var
import pandas as pd
from Bio import SeqIO
from Bio.Seq import Seq
from datetime import datetime
from openpyxl import load_workbook, Workbook


def get_variable (first_hit, second_hit, seq, orientation, antisense):
        variable = ""
        status = ""

        if orientation == "forward":
            start = int(second_hit [7])
            end = int(first_hit [6])-1
            
            if (start<end) & ((end-start)%3==0): # checks that the region is divisible by 3
                if not(antisense):
                    variable = str(seq[start:end].translate())
                else:
                    variable = str(seq[start:end].reverse_complement().translate())
            else:
                status = "variable_wrong_len"
            
        if orientation == "reverse":
            start = int(second_hit [6])-1
            end = int(first_hit [7])
            
            if (end<start) & ((end-start)%3==0): # checks that the region is divisible by 3
                if not(antisense):
                    variable = str(seq[end:start].reverse_complement().translate())
                else:
                    variable = str(seq[end:start].translate())
            else:
                status = "variable_wrong_len"   
    
        if len(second_hit[1].split("-")) == 3: # name, 5 prime, length
            correct_length_part = second_hit[1].split('-')[2]  # Extracts length
        
        else:
            correct_length_part = -1

        # Check if it's a list of acceptable lengths
        if ',' in correct_length_part:
            acceptable_lengths = list(map(int, correct_length_part.split(',')))  # Convert to a list of integers
            if len(variable) not in acceptable_lengths:
                variable = ""
                status = "variable_wrong_len"
        else:
            correct_length = int(correct_length_part)
            if not(len(variable) == correct_length):
                variable = ""
                status = "variable_wrong_len"

        return variable, status

def count_sequences_in_fasta(file_path):
    if os.path.exists(file_path):  # Check if file exists
        with open(file_path, 'r') as fasta_file:
            sequence_count = 0
            for line in fasta_file:
                if line.startswith(">"):  # Each header line marks a new sequence
                    sequence_count += 1
            return sequence_count
    else:
        return 0

def write_to_excel(file_name, row_data):
    try:
        # Try to load the workbook if it exists
        workbook = load_workbook(file_name)
        sheet = workbook.active
    except FileNotFoundError:
        # If the file doesn't exist, create a new workbook
        workbook = Workbook()
        sheet = workbook.active
        # Add variables (if desired)
        sheet.append(["Library", "Success", "Variable Wrong Length", "Missing Flanking Region", "Read Too Short" , "Success %", "Variable Wrong Length %", "Missing Flanking Region %", "Read Too Short %" , "Timestamp"])

    # Append the new row
    sheet.append(row_data)

    # Save the workbook
    workbook.save(file_name)

def sort_key(x):
    name = x[1]  
    parts = name.split("_")

    # Pull out digits (your current approach)
    digits = int(''.join(filter(str.isdigit, parts[1])))

    # Find "3prime" or "5prime"
    if "3prime" in name:
        prime_val = 0
    elif "5prime" in name:
        prime_val = 1
    else:
        prime_val = 2  # fallback if neither found

    return (digits, prime_val, name)


# initialize
library = sys.argv[1]
df = pd.read_excel("config.xlsx")
num_regions = len(df[df["Variable/Constant"].str.lower() == "variable"])

fasta_file = f"files/{library}/{library}_len_pass.fasta" # fasta file of reads
blast_file = f"files/{library}/{library}_vs_flanking_regions.txt" # blast output (generated by this code)
db_file = "blastdb/flanking_regions.fasta"
summary_file = "extraction_summary.xlsx" # summary of extraction success

print (f"extracting variable regions from {library} ")



# read blast alignment summaries into dictionary
alignment_dict = {}
with open(blast_file, 'r') as file:
    for line in file:
        parts = line.strip().split("\t")
        read_id = parts[0]
        if read_id not in alignment_dict:
            alignment_dict[read_id] = []
        alignment_dict[read_id].append(parts)



# get the names of the variable regions from the blast database
variables = []
with open(db_file, "r") as file:
    for line in file:
        line = line.strip()
        if line.startswith(">"):  # Indicates a header line in FASTA
            # Extract the prefix before the first underscore
            prefix = line.split("-")[0][1:]
            if prefix not in variables:
                variables.append(prefix)


# get the constant regions from the config file
df_const = df[df["Variable/Constant"].str.lower() == "constant"]

constants = {}
for _, row in df_const.iterrows():
    protein = row["Protein"].replace(" ", "_")  # e.g. MHC A3 â†’ MHC_A3
    value = str(row["WT Residue"]).strip()  # your constants (aaaa, bbbb, etc.)

    # make a label; since constants have no start/length, use region number
    region_id = f"{protein}_const{row['Region']}"
    constants[region_id] = value

print(constants)



# extract the variable regions
rows = [] # this becomes the output spreadsheet
missing_flanking_region = 0
variable_wrong_len = 0
good = 0

for record in SeqIO.parse(fasta_file, "fasta"):
    seq_id = record.id  # Extract the sequence ID from the FASTA file
    seq = record.seq # extract the sequence
    
    hits = alignment_dict.get(seq_id, []) # get all of the blast hits for the read
    if len(hits) == num_regions*2:
        double_checker = False # used to prevent adding to variable_wrong_len multiple times when multiple regions in a read have bad coordinates
        
        # checks the subject start and end of the first alignment to determine whether the read is the reverse compliment of what we want
        orientation = ""
        var1_qstart = hits [0][8]
        var1_qend = hits [0][9]
        if var1_qstart < var1_qend:
            orientation = "forward"
        else:
            orientation = "reverse"
        
        
        row_data = {"readID": seq_id}
        for variable in variables: # the code iterates through the variable regions like this so that they get written in the order that they were specified in the blast file
            matching_hits = [hit for hit in hits if hit[1].startswith(variable + "-")] # gets the two hits for the variable region in question
            
            matching_hits.sort(key=sort_key)
            #matching_hits.sort(key=lambda x: int(''.join(filter(str.isdigit, x[1].split("_")[1]))))  # sorts them so that the 3 prime hit comes first
            
            if (len(matching_hits) == 2):
                if matching_hits[1][1].split("-")[-1] == "R": # check the end of the 5prime hit's label to see whether to translate the antisense strand
                    antisense = True
                else:
                    antisense = False

                row_data[variable], status =  get_variable (matching_hits[0], matching_hits[1], seq, orientation, antisense)
                if status == "variable_wrong_len" and double_checker == False:
                    variable_wrong_len += 1
                    double_checker = True
            else:
                missing_flanking_region += 1
        
        if not([key for key in variables if key not in row_data or not row_data[key]]): # only append row if variable regions were extracted successfully

            # Get ordered lists of constants and variables
            constants_items = list(constants.values())
            variables_items = [row_data[v] for v in variables if v in row_data]

            # Check list length condition
            if len(constants_items) != len(variables_items) + 1:
                raise ValueError(f"Constants list must be one longer than variables list. Got {len(constants_items)} vs {len(variables_items)}")

            # Normalize case
            constants_items = [c.lower() for c in constants_items]
            variables_items = [v.upper() for v in variables_items]

            # Interleave
            stitched = "".join(c + v for c, v in zip(constants_items, variables_items)) + constants_items[-1]
            print (stitched)
            # Add to row_data
            row_data["Complete Sequence"] = stitched


            rows.append(row_data)
            good+=1

    else:
        missing_flanking_region +=1

print ("variable region extraction complete")

df = pd.DataFrame(rows)
df.to_csv (f"files/{library}/{library}.csv", index=False)



# Write the summary values to the Excel file
too_short = count_sequences_in_fasta (f"files/{library}/{library}_len_fail.fasta")

total = good + variable_wrong_len + missing_flanking_region + too_short
good_percent = 100*(good/total)
variable_wrong_len_percent = 100*(variable_wrong_len/total)
missing_flanking_region_percent = 100*(missing_flanking_region/total)
too_short_percent = 100*(too_short/total)
timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

good_percent_fmt = f"{good_percent:,.2f}"  # Two decimal places
missing_flanking_region_percent_fmt = f"{missing_flanking_region_percent:,.2f}"
variable_wrong_len_percent_fmt = f"{variable_wrong_len_percent:,.2f}"
too_short_percent_fmt = f"{too_short_percent:,.2f}"

write_to_excel(summary_file, [library, good, variable_wrong_len, missing_flanking_region, too_short, good_percent_fmt, variable_wrong_len_percent_fmt, missing_flanking_region_percent_fmt, too_short_percent_fmt, timestamp])
