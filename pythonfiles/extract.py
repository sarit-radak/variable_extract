import os
import re
import sys
import time
import pandas as pd
from numpy import var
from Bio import SeqIO
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord

from datetime import datetime
from collections import defaultdict
from openpyxl import load_workbook, Workbook


def get_variable (first_hit, second_hit, seq, orientation, antisense):
        variable = ""
        status = ""

        if orientation == "forward":
            start = int(second_hit [7])
            end = int(first_hit [6])-1
            
            if (start<end) & ((end-start)%3==0): # checks that the region is divisible by 3
                if not(antisense):
                    variable = str(seq[start:end].translate())
                else:
                    variable = str(seq[start:end].reverse_complement().translate())
            else:
                status = "variable_wrong_len"
            
        if orientation == "reverse":
            start = int(second_hit [6])-1
            end = int(first_hit [7])

            if (end<start) & ((end-start)%3==0): # checks that the region is divisible by 3
                if not(antisense):
                    variable = str(seq[end:start].reverse_complement().translate())
                else:
                    variable = str(seq[end:start].translate())
            else:
                status = "variable_wrong_len"   
    
        correct_length_part = second_hit[1].split('-')[2]  # extracts length
        
        

        # Check if it's a list of acceptable lengths
        if ',' in correct_length_part:
            acceptable_lengths = list(map(int, correct_length_part.split(',')))  # convert to a list of integers
            if len(variable) not in acceptable_lengths:
                variable = ""
                status = "variable_wrong_len"
        else:
            correct_length = int(correct_length_part)
            if not(len(variable) == correct_length):
                variable = ""
                status = "variable_wrong_len"

        return variable, status

def count_sequences_in_fasta(file_path):
    if os.path.exists(file_path):  # Check if file exists
        with open(file_path, 'r') as fasta_file:
            sequence_count = 0
            for line in fasta_file:
                if line.startswith(">"):  # Each header line marks a new sequence
                    sequence_count += 1
            return sequence_count
    else:
        return 0

def write_to_excel(file_name, row_data):
    try:
        # Try to load the workbook if it exists
        workbook = load_workbook(file_name)
        sheet = workbook.active
    except FileNotFoundError:
        # If the file doesn't exist, create a new workbook
        workbook = Workbook()
        sheet = workbook.active
        # Add variables (if desired)
        sheet.append(["Library", "Success", "Variable Wrong Length", "Missing Flanking Region", "Read Too Short" , "Success %", "Variable Wrong Length %", "Missing Flanking Region %", "Read Too Short %" , "Timestamp"])

    # Append the new row
    sheet.append(row_data)

    # Save the workbook
    workbook.save(file_name)

def sort_key(x):
    name = x[1]  
    parts = name.split("_")

    # Pull out digits (your current approach)
    digits = int(''.join(filter(str.isdigit, parts[1])))

    # Find "3prime" or "5prime"
    if "3prime" in name:
        prime_val = 0
    elif "5prime" in name:
        prime_val = 1
    else:
        prime_val = 2  # fallback if neither found

    return (digits, prime_val, name)

def format_elapsed(seconds: float) -> str:
    if seconds < 1:
        return f"{seconds*1000:.0f} ms"
    elif seconds < 60:
        return f"{seconds:.2f} seconds"
    elif seconds < 3600:
        m, s = divmod(seconds, 60)
        return f"{int(m)}m {s:.1f}s"
    else:
        h, rem = divmod(seconds, 3600)
        m, s = divmod(rem, 60)
        return f"{int(h)}h {int(m)}m {s:.0f}s"


print ("")
print("Extracting variable regions from reads...")
start = time.time()

library = sys.argv[1]
df = pd.read_excel("config.xlsx")
num_regions = len(df[df["Variable/Constant"].str.lower() == "variable"])

fasta_file = f"files/{library}/{library}_len_pass.fasta" # fasta file of reads
blast_file = f"files/{library}/{library}_vs_flanking_regions.txt" # blast output (generated by this code)
db_file = "blastdb/flanking_regions.fasta"
summary_file = "extraction_summary.xlsx" # summary of extraction success



# read blast alignment summaries into dictionary
alignment_dict = {}
with open(blast_file, 'r') as file:
    for line in file:
        parts = line.strip().split("\t")
        read_id = parts[0]
        if read_id not in alignment_dict:
            alignment_dict[read_id] = []
        alignment_dict[read_id].append(parts)



# get the names of the variable regions from the blast database
variables = []
with open(db_file, "r") as file:
    for line in file:
        line = line.strip()
        if line.startswith(">"):
            prefix = line.split("-")[0][1:]
            if prefix not in variables:
                variables.append(prefix)


# get the constant regions from the config file
df_const = df[df["Variable/Constant"].str.lower() == "constant"]

constants = {}
for _, row in df_const.iterrows():
    protein = row["Protein"].replace(" ", "_")
    value = str(row["WT Residue"]).strip()
    region_id = f"{protein}_const{row['Region']}"
    constants[region_id] = value



# extract the variable regions
rows = [] # this becomes the output spreadsheet
failed_records = []
missing_flanking_region = 0
variable_wrong_len = 0
good = 0

for record in SeqIO.parse(fasta_file, "fasta"):
    seq_id = record.id  # extract the sequence ID from the FASTA file
    seq = record.seq # extract the sequence
    
    hits = alignment_dict.get(seq_id, []) # get all of the blast hits for the read
    if len(hits) == num_regions*2:
        double_checker = False # used to prevent adding to variable_wrong_len multiple times when multiple regions in a read have bad coordinates
        
        # checks the subject start and end of the first alignment to determine whether the read is the reverse compliment of what we want
        orientation = ""
        var1_qstart = hits [0][8]
        var1_qend = hits [0][9]
        if var1_qstart < var1_qend:
            orientation = "forward"
        else:
            orientation = "reverse"
        
        
        row_data = {"readID": seq_id}
        for variable in variables: # the code iterates through the variable regions like this so that they get written in the order that they were specified in the blast file
            matching_hits = [hit for hit in hits if hit[1].startswith(variable + "-")] # gets the two hits for the variable region in question
            
            matching_hits.sort(key=sort_key)
            
            if (len(matching_hits) == 2):
                if matching_hits[1][1].split("-")[-1] == "R": # check the end of the 5prime hit's label to see whether to translate the antisense strand
                    antisense = True
                else:
                    antisense = False

                row_data[variable], status =  get_variable (matching_hits[0], matching_hits[1], seq, orientation, antisense)

                if status == "variable_wrong_len" and double_checker == False:
                    variable_wrong_len += 1
                    double_checker = True
                    failed_records.append(SeqRecord(seq, id=f"{seq_id}|wrong_len", description=""))
            else:
                missing_flanking_region += 1
                failed_records.append(SeqRecord(seq, id=f"{seq_id}|missing_flank", description=""))
        
        else:
            failed_records.append(SeqRecord(seq, id=f"{seq_id}|wrong_num_hits", description=""))

        

        if not([key for key in variables if key not in row_data or not row_data[key]]):  # only append row if variable regions were extracted successfully
            const_groups_idx = defaultdict(list)  # protein -> list[(index, seq_lower)]
            for ck, cv in constants.items():
                prot = ck.split('_const')[0]  # e.g. 'MHC_A3', 'B2M'
                m = re.search(r'(\d+)$', ck)
                cidx = int(m.group(1)) if m else 0
                const_groups_idx[prot].append((cidx, str(cv).lower()))
            for prot in const_groups_idx:
                const_groups_idx[prot].sort()


            var_groups_idx = defaultdict(list)
            for vk, vv in row_data.items():
                if vk in ("readID", "Complete Sequence") or not isinstance(vv, str):
                    continue
                if not re.search(r'\d', vk):
                    continue

                prot = next((p for p in const_groups_idx if vk.startswith(p + "_")), None)
                if prot is None:
                    m = re.match(r'^(.+?)(?=_\d)', vk)
                    prot = m.group(1) if m else None
                if prot is None:
                    continue

                vidx = int(re.search(r'(\d+)', vk).group())
                var_groups_idx[prot].append((vidx, str(vv).upper()))
            for prot in var_groups_idx:
                var_groups_idx[prot].sort()

            protein_order = sorted(const_groups_idx.keys(), key=lambda p: const_groups_idx[p][0][0])

            for prot in protein_order:
                consts = [s for _, s in const_groups_idx[prot]]
                vars_  = [s for _, s in var_groups_idx.get(prot, [])]

                if len(consts) != len(vars_) + 1:
                    raise ValueError(f"{prot}: expected len(constants)=len(variables)+1, got {len(consts)} vs {len(vars_)}")

                block = "".join(c + v for c, v in zip(consts, vars_)) + consts[-1]

                col_name = prot.replace("_", " ")
                row_data[col_name] = block

            rows.append(row_data)
            good += 1

    else:
        missing_flanking_region +=1

df = pd.DataFrame(rows)
df.to_csv (f"files/{library}/{library}.csv", index=False)

if failed_records:
    SeqIO.write(failed_records, f"files/{library}/{library}_extract_fail.fasta", "fasta")


# write the summary values to the Excel file
too_short = count_sequences_in_fasta (f"files/{library}/{library}_len_fail.fasta")

total = good + variable_wrong_len + missing_flanking_region + too_short
good_percent = 100*(good/total)
variable_wrong_len_percent = 100*(variable_wrong_len/total)
missing_flanking_region_percent = 100*(missing_flanking_region/total)
too_short_percent = 100*(too_short/total)
timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

good_percent_fmt = f"{good_percent:,.2f}"  # Two decimal places
missing_flanking_region_percent_fmt = f"{missing_flanking_region_percent:,.2f}"
variable_wrong_len_percent_fmt = f"{variable_wrong_len_percent:,.2f}"
too_short_percent_fmt = f"{too_short_percent:,.2f}"

write_to_excel(summary_file, [library, good, variable_wrong_len, missing_flanking_region, too_short, good_percent_fmt, variable_wrong_len_percent_fmt, missing_flanking_region_percent_fmt, too_short_percent_fmt, timestamp])

end = time.time()

elapsed = end - start
print (f"Variable region extraction complete in {format_elapsed(elapsed)}")